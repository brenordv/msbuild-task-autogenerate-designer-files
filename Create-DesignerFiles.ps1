param (
    [Parameter(Mandatory=$true)][string]$path,
    [Parameter(Mandatory=$true)][string]$namespace,
    [switch]$backup = $false
)

<#
    .SYNOPSIS
    This script will search for .resx files and generate .Designer.cs for them. It's a dependency-free approach.
    If necessary, the templates can be altered to fit another format. For now, it works fine.

    This script needs serious house-keeping and refactoring, but I'll test it a bit more first.

    .PARAMETER path
    Path to be used as base to search for .resx files. The search is recursive.

    .PARAMETER namespace
    Namespace to be included in the generated designer.cs files.

    .PARAMETER backup
    If true, will generate a backup of existing designer files. (Default is false)
    
    .EXAMPLE
    Creates designer files without backup
    PS> Create-DesignerFiles.ps1 -path c:\path\to\project -namespace Project.Namespace
    
    .EXAMPLE
    Creates designer files with backup
    PS> Create-DesignerFiles.ps1 -path c:\path\to\project -namespace Project.Namespace -backup
    
    .LINK
    Repo: https://github.com/brenordv/msbuild-task-autogenerate-designer-files
#>


$scriptVer = "1.0.0.0"

$designerTempalte = @"
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a PowerShell Script.
//     Script version: ##SCRIPTVER##
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace ##NAMESPACE## {
    using System;
    
    
    /// <summary>
    ///   A strongly-typed resource class, for looking up localized strings, etc.
    /// </summary>
    // This class was auto-generated by the StronglyTypedResourceBuilder
    // class via a tool like ResGen or Visual Studio.
    // To add or remove a member, edit your .ResX file then rerun ResGen
    // with the /str option, or rebuild your VS project.
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "4.0.0.0")]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    public class ##CLASS_NAME## {
        
        private static global::System.Resources.ResourceManager resourceMan;
        
        private static global::System.Globalization.CultureInfo resourceCulture;
        
        [global::System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode")]
        internal ##CLASS_NAME##() {
        }
        
        /// <summary>
        ///   Returns the cached ResourceManager instance used by this class.
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        public static global::System.Resources.ResourceManager ResourceManager {
            get {
                if (object.ReferenceEquals(resourceMan, null)) {
                    global::System.Resources.ResourceManager temp = new global::System.Resources.ResourceManager("##NAMESPACE##.##ORIGINAL_FILE_NAME##", typeof(##CLASS_NAME##).Assembly);
                    resourceMan = temp;
                }
                return resourceMan;
            }
        }
        
        /// <summary>
        ///   Overrides the current thread's CurrentUICulture property for all
        ///   resource lookups using this strongly typed resource class.
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        public static global::System.Globalization.CultureInfo Culture {
            get {
                return resourceCulture;
            }
            set {
                resourceCulture = value;
            }
        }
		
		##DATA##

    }
}
"@

$designerDataTemplate = @"
       
        /// <summary>
        ///   Looks up a localized string similar to ##VALUE##
        /// </summary>
        public static string ##KEY## {
            get {
                return ResourceManager.GetString("##KEY##", resourceCulture);
            }
        }
"@

# Recursively looking for every .resx file, starting from informed path.
Get-ChildItem -Path $path -Filter *.resx -Recurse -File | ForEach-Object {
    Write-Host 'Working on RESX file:' $_.Name -ForegroundColor Green -NoNewline

    # Getting RESX file content.
    [xml]$xml = Get-Content -Path $_.FullName

    # Creating new filename for 
    $designerFilename = $_.FullName -replace ".resx", ".Designer.cs"
    
    # Creates the adapted class name
    $className = $_.BaseName -replace "\.", "_" -replace "-", "_"

    # Extracts data nov
    $xmlDataObj = $xml.SelectNodes("//data")
    $dataObjs = @()

    # Processing each data node for the current file.
    foreach ($d in $xmlDataObj) {
        # Finds res value.
        $value = "## NOT FOUND##"
        foreach ($cn in $d.ChildNodes) {
            if ($cn.Name -ne "value") { continue }
            $value = $cn.InnerText
            break
        }        

        # Finds the key value.
        $key = "##NOT  FOUND##"
        foreach ($attr in $d.Attributes) {
            if ($attr.Name -ne "name") { continue }
            $key = $attr.Value
            break
        }

        # Create file entry based on template.
        $dtData = $designerDataTemplate -replace "##VALUE##", $value -replace "##KEY##", $key

        # Adds this to the array of entries.
        $dataObjs += $dtData        
    }

    # Joins every data entry into a single string.
    $dataStr = [string]::Join("", $dataObjs) 

    # Replaces all tokens in the file template, creating the content of the new designer.cs file.
    $newDesignerFileContent = $designerTempalte -replace "##ORIGINAL_FILE_NAME##", $_.BaseName -replace "##SCRIPTVER##", $scriptVer -replace "##NAMESPACE##", $namespace -replace "##CLASS_NAME##", $className -replace "##DATA##", $dataStr

    # Checks if a designer file already exists and creates a backup of the current one (if needed)
    $hasDesignerFile = Test-Path -Path $designerFilename
    if ($backup -and $hasDesignerFile) {
        $backupFilename = $designerFilename +"."+ [Math]::Round((Get-Date).ToFileTime()/10000) + '.backup'
        Copy-Item -Path $designerFilename -Destination $backupFilename        
    }

    # Replace/create designer.cs file for the current RESX
    Set-Content -Path $designerFilename -Value $newDesignerFileContent
    Write-Host ' Done!' -ForegroundColor Green
}
